# 泛型

## 泛型的定义
泛型（Generics），即“类型参数化”。如果对某个参数的类型不明确，就可以使用泛型代替。  

## 泛型入门
现在想要定义一个简单的 `identity` 方法，接收 `number` 类型参数， 返回参数本身：  
```ts
function identity(arg: number): number {
  return arg
}
```  
但是现在不明确参数 `arg` 的类型，可以使用 `any` 类型来定义:  
```ts
function identity(arg: any): any {
  return arg
}
```  
这样写仍然存在问题，返回可以是 `any` 类型，不一定是参数 `arg` 的类型，同时也丢失了 `arg` 类型信息，此时可以使用泛型来重写该方法：  
```ts
function identity<T>(arg: T): T {
  return arg
}
```  
函数名后加上 `<T>` 来表明该方法是**泛型方法**，`T` 是一个类型变量（这里就是将类型定义成变量 `T` 了，不需要写死类型为 `number`等明确类型），类型参数可以定义为任意字符，常用的还有 `K`、`V`、`E`等，方法中可以使用定义过的类型参数作为类型使用。  
给 `identity` 添加类型变量 `T` 之后， `T` 帮助我们捕获用户传入的类型（如：`number`），之后便可以使用这个类型。  

使用泛型函数  
- 第一种方法： 传入所有参数，包括类型参数：
  ```ts
  let output = identity<string>('myString')
  ```  
- 第二种方法： 利用类型推论自动确定类型参数T的类型：  
  ```ts
  let output = identity('myString')
  ```

## 使用泛型变量
1. 使用泛型变量时，必须将其当作通用类型来看待   
    例如 `identity` 方法中想要打印 `arg` 参数的长度，可能会这么做：  
    ```ts
    function identity<T>(arg: T): T {
      console.log(arg.length)
      return arg
    } 
    ```  
    这样是错误的，`T` 要当作通用类型看待，而如果传入的是 `number`类型，是没有 `length`属性的。  

2. 如果想要传入的参数是数组，可以这么定义：  
   ```ts
   function identity<T>(arg: T[]): T[] {
     console.log(arg.length)
     return arg
   }
   ```  
   或者  
   ```ts
   function identity<T>(arg: Array<T>): Array<T> {
     console.log(arg.length)
     return arg
   }
   ```  


